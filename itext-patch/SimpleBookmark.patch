# This patch file was generated by NetBeans IDE
# Following Index: paths are relative to: D:\Docs\iText_2_1_7\src\core\com\lowagie\text\pdf
# This patch can be applied using context Tools: Patch action on respective folder.
# It uses platform neutral UTF-8 encoding and \n newlines.
# Above lines and this line are ignored by the patching process.
Index: SimpleBookmark.java
--- SimpleBookmark.java Base (BASE)
+++ SimpleBookmark.java Locally Modified (Based On LOCAL)
@@ -45,6 +45,33 @@
  * http://www.lowagie.com/iText/
  */
 
+
+/*
+ * SimpleBookmark.java
+ *
+ * Some parts of this source file have been modified or added to fit the 
+ * needs of the program JPdfBookmarks, these parts have been marked in source 
+ * code and are released according to the following license.
+ * 
+ * Copyright (c) 2010 Flaviano Petrocchi <flavianopetrocchi at gmail.com>.
+ * All rights reserved.
+ *
+ * This file is part of JPdfBookmarks.
+ *
+ * JPdfBookmarks is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * JPdfBookmarks is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with JPdfBookmarks.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.lowagie.text.pdf;
 
 import java.io.BufferedWriter;
@@ -392,18 +419,162 @@
         }
     }
     
-    static void createOutlineAction(PdfDictionary outline, HashMap map, PdfWriter writer, boolean namedAsNames) {
+    /*
+    * Added by Flaviano Petrocchi for use within JPdfBookmarks. 
+    */
+    static PdfDictionary createActionDictionary(HashMap<String, Object> map, PdfWriter writer, boolean namedAsNames) {
+
+        PdfDictionary dic = new PdfDictionary();
         try {
-            String action = (String)map.get("Action");
+            String action = (String) map.get("Action");
             if ("GoTo".equals(action)) {
                 String p;
-                if ((p = (String)map.get("Named")) != null) {
-                    if (namedAsNames)
+                dic.put(PdfName.S, PdfName.GOTO);
+                if ((p = (String) map.get("Named")) != null) {
+                    if (namedAsNames) {
+                        dic.put(PdfName.D, new PdfName(p));
+                    } else {
+                        dic.put(PdfName.D, new PdfString(p, null));
+                    }
+                } else if ((p = (String) map.get("Page")) != null) {
+                    PdfArray ar = new PdfArray();
+                    StringTokenizer tk = new StringTokenizer(p);
+                    int n = Integer.parseInt(tk.nextToken());
+                    ar.add(writer.getPageReference(n));
+                    if (!tk.hasMoreTokens()) {
+                        ar.add(PdfName.XYZ);
+                        ar.add(new float[]{0, 10000, 0});
+                    } else {
+                        String fn = tk.nextToken();
+                        if (fn.startsWith("/")) {
+                            fn = fn.substring(1);
+                        }
+                        ar.add(new PdfName(fn));
+                        for (int k = 0; k < 4 && tk.hasMoreTokens(); ++k) {
+                            fn = tk.nextToken();
+                            if (fn.equals("null")) {
+                                ar.add(PdfNull.PDFNULL);
+                            } else {
+                                ar.add(new PdfNumber(fn));
+                            }
+                        }
+                    }
+                    dic.put(PdfName.D, ar);
+                }
+            } else if ("GoToR".equals(action)) {
+                String p;
+                if ((p = (String) map.get("Named")) != null) {
+                    dic.put(PdfName.D, new PdfString(p, null));
+                } else if ((p = (String) map.get("NamedN")) != null) {
+                    dic.put(PdfName.D, new PdfName(p));
+                } else if ((p = (String) map.get("Page")) != null) {
+                    PdfArray ar = new PdfArray();
+                    StringTokenizer tk = new StringTokenizer(p);
+                    ar.add(new PdfNumber(tk.nextToken()));
+                    if (!tk.hasMoreTokens()) {
+                        ar.add(PdfName.XYZ);
+                        ar.add(new float[]{0, 10000, 0});
+                    } else {
+                        String fn = tk.nextToken();
+                        if (fn.startsWith("/")) {
+                            fn = fn.substring(1);
+                        }
+                        ar.add(new PdfName(fn));
+                        for (int k = 0; k < 4 && tk.hasMoreTokens(); ++k) {
+                            fn = tk.nextToken();
+                            if (fn.equals("null")) {
+                                ar.add(PdfNull.PDFNULL);
+                            } else {
+                                ar.add(new PdfNumber(fn));
+                            }
+                        }
+                    }
+                    dic.put(PdfName.D, ar);
+                }
+                String file = (String) map.get("File");
+                if (dic.size() > 0 && file != null) {
+                    dic.put(PdfName.S, PdfName.GOTOR);
+                    dic.put(PdfName.F, new PdfString(file));
+                    String nw = (String) map.get("NewWindow");
+                    if (nw != null) {
+                        if (nw.equals("true")) {
+                            dic.put(PdfName.NEWWINDOW, PdfBoolean.PDFTRUE);
+                        } else if (nw.equals("false")) {
+                            dic.put(PdfName.NEWWINDOW, PdfBoolean.PDFFALSE);
+                        }
+                    }
+                }
+            } else if ("URI".equals(action)) {
+                String uri = (String) map.get("URI");
+                if (uri != null) {
+                    dic.put(PdfName.S, PdfName.URI);
+                    dic.put(PdfName.URI, new PdfString(uri));
+                }
+            } else if ("Launch".equals(action)) {
+                String file = (String) map.get("File");
+                if (file != null) {
+                    dic.put(PdfName.S, PdfName.LAUNCH);
+                    dic.put(PdfName.F, new PdfString(file));
+                }
+            }
+
+
+            ArrayList<HashMap> chainedActionsMaps = (ArrayList<HashMap>) map.get("Next");
+            if (chainedActionsMaps != null && !chainedActionsMaps.isEmpty()) {
+                PdfDictionary fatherDict = dic;
+                PdfDictionary[] dictsToAdd = new PdfDictionary[chainedActionsMaps.size()];
+                PdfIndirectReference[] dictsRefToAdd = new PdfIndirectReference[chainedActionsMaps.size()];
+                int i = 0;
+                for (HashMap chainedMap : chainedActionsMaps) {
+                    //createOutlineAction(newAction, chainedMap, writer, namedAsNames);
+                    PdfDictionary chainedDict = createActionDictionary(chainedMap, writer, namedAsNames);
+                    PdfIndirectReference chainedDictRef = writer.getPdfIndirectReference();
+                    dictsToAdd[i] = chainedDict;
+                    dictsRefToAdd[i] = chainedDictRef;
+                    fatherDict.put(PdfName.NEXT, chainedDictRef);
+                    fatherDict = chainedDict;
+                    i++;
+                }
+                for (int j = 0; j < dictsToAdd.length; j++) {
+                    writer.addToBody(dictsToAdd[j], dictsRefToAdd[j]);
+                }
+            }
+
+        } catch (Exception e) {
+            // empty on purpose
+        } finally {
+            return dic; //always return something (not sure this is ok)
+        }
+    }
+    
+   /*
+    * Added by Flaviano Petrocchi for use within JPdfBookmarks. 
+    */
+    static void createChainedOutlineAction(PdfDictionary outline, HashMap<String, Object> map, PdfWriter writer, boolean namedAsNames) {
+        try {
+            PdfDictionary dic = createActionDictionary(map, writer, namedAsNames);
+            if (dic != null) {
+                PdfIndirectReference dicRef = writer.getPdfIndirectReference();
+                writer.addToBody(dic, dicRef);
+                outline.put(PdfName.A, dicRef);
+            }
+        } catch (Exception e) {
+            // empty on purpose
+        }
+    }
+
+    static void createOutlineAction(PdfDictionary outline, HashMap<String, Object> map, PdfWriter writer, boolean namedAsNames) {
+        try {
+            String action = (String) map.get("Action");
+            if ("GoTo".equals(action)) {
+                String p;
+                if ((p = (String) map.get("Named")) != null) {
+                    if (namedAsNames) {
                         outline.put(PdfName.DEST, new PdfName(p));
-                    else
+                    } else {
                         outline.put(PdfName.DEST, new PdfString(p, null));
                 }
-                else if ((p = (String)map.get("Page")) != null) {
+                } else if ((p = (String) map.get("Page")) != null) {
                     PdfArray ar = new PdfArray();
                     StringTokenizer tk = new StringTokenizer(p);
                     int n = Integer.parseInt(tk.nextToken());
@@ -411,78 +582,78 @@
                     if (!tk.hasMoreTokens()) {
                         ar.add(PdfName.XYZ);
                         ar.add(new float[]{0, 10000, 0});
-                    }
-                    else {
+                    } else {
                         String fn = tk.nextToken();
-                        if (fn.startsWith("/"))
+                        if (fn.startsWith("/")) {
                             fn = fn.substring(1);
+                        }
                         ar.add(new PdfName(fn));
                         for (int k = 0; k < 4 && tk.hasMoreTokens(); ++k) {
                             fn = tk.nextToken();
-                            if (fn.equals("null"))
+                            if (fn.equals("null")) {
                                 ar.add(PdfNull.PDFNULL);
-                            else
+                            } else {
                                 ar.add(new PdfNumber(fn));
                         }
                     }
+                    }
                     outline.put(PdfName.DEST, ar);
                 }
-            }
-            else if ("GoToR".equals(action)) {
+            } else if ("GoToR".equals(action)) {
                 String p;
                 PdfDictionary dic = new PdfDictionary();
-                if ((p = (String)map.get("Named")) != null)
+                if ((p = (String) map.get("Named")) != null) {
                     dic.put(PdfName.D, new PdfString(p, null));
-                else if ((p = (String)map.get("NamedN")) != null)
+                } else if ((p = (String) map.get("NamedN")) != null) {
                     dic.put(PdfName.D, new PdfName(p));
-                else if ((p = (String)map.get("Page")) != null){
+                } else if ((p = (String) map.get("Page")) != null) {
                     PdfArray ar = new PdfArray();
                     StringTokenizer tk = new StringTokenizer(p);
                     ar.add(new PdfNumber(tk.nextToken()));
                     if (!tk.hasMoreTokens()) {
                         ar.add(PdfName.XYZ);
                         ar.add(new float[]{0, 10000, 0});
-                    }
-                    else {
+                    } else {
                         String fn = tk.nextToken();
-                        if (fn.startsWith("/"))
+                        if (fn.startsWith("/")) {
                             fn = fn.substring(1);
+                        }
                         ar.add(new PdfName(fn));
                         for (int k = 0; k < 4 && tk.hasMoreTokens(); ++k) {
                             fn = tk.nextToken();
-                            if (fn.equals("null"))
+                            if (fn.equals("null")) {
                                 ar.add(PdfNull.PDFNULL);
-                            else
+                            } else {
                                 ar.add(new PdfNumber(fn));
                         }
                     }
+                    }
                     dic.put(PdfName.D, ar);
                 }
-                String file = (String)map.get("File");
+                String file = (String) map.get("File");
                 if (dic.size() > 0 && file != null) {
-                    dic.put(PdfName.S,  PdfName.GOTOR);
+                    dic.put(PdfName.S, PdfName.GOTOR);
                     dic.put(PdfName.F, new PdfString(file));
-                    String nw = (String)map.get("NewWindow");
+                    String nw = (String) map.get("NewWindow");
                     if (nw != null) {
-                        if (nw.equals("true"))
+                        if (nw.equals("true")) {
                             dic.put(PdfName.NEWWINDOW, PdfBoolean.PDFTRUE);
-                        else if (nw.equals("false"))
+                        } else if (nw.equals("false")) {
                             dic.put(PdfName.NEWWINDOW, PdfBoolean.PDFFALSE);
                     }
+                    }
                     outline.put(PdfName.A, dic);
                 }
-            }
-            else if ("URI".equals(action)) {
-                String uri = (String)map.get("URI");
+            } else if ("URI".equals(action)) {
+                String uri = (String) map.get("URI");
                 if (uri != null) {
                     PdfDictionary dic = new PdfDictionary();
                     dic.put(PdfName.S, PdfName.URI);
                     dic.put(PdfName.URI, new PdfString(uri));
                     outline.put(PdfName.A, dic);
                 }
-            }
-            else if ("Launch".equals(action)) {
-                String file = (String)map.get("File");
+            } else if ("Launch".equals(action)) {
+                String file = (String) map.get("File");
                 if (file != null) {
                     PdfDictionary dic = new PdfDictionary();
                     dic.put(PdfName.S, PdfName.LAUNCH);
@@ -490,12 +661,14 @@
                     outline.put(PdfName.A, dic);
                 }
             }
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             // empty on purpose
         }
     }
 
+    /*
+    * Added by Flaviano Petrocchi for use within JPdfBookmarks. 
+    */
     public static Object[] iterateOutlines(PdfWriter writer, PdfIndirectReference parent, List kids, boolean namedAsNames) throws IOException {
         PdfIndirectReference refs[] = new PdfIndirectReference[kids.size()];
         for (int k = 0; k < refs.length; ++k)
@@ -553,7 +726,8 @@
                 if (bits != 0)
                     outline.put(PdfName.F, new PdfNumber(bits));
             }
-            createOutlineAction(outline, map, writer, namedAsNames);
+            //createOutlineAction(outline, map, writer, namedAsNames);
+            createChainedOutlineAction(outline, map, writer, namedAsNames);
             writer.addToBody(outline, refs[ptr]);
         }
         return new Object[]{refs[0], refs[refs.length - 1], new Integer(count)};
